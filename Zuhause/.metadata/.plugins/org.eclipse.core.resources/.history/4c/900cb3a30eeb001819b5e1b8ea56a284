/************************************
 * Filename		 : UE01_strgout.c	*
 * Created on	 : Nov 17, 2018		*
 * Author		 : Christian Zahner	*
 ************************************/


#include "UART0.h"
#include "support_common.h"  // include peripheral declarations and more; 
#include "uart_support.h"    // universal asynchronous receiver transmitter,
                             // (d.h. die serielle Schnittstelle)
#include "terminal_wrapper.h"
#include <stdio.h>

#include "UE01_Strgout.h"


  void strgout(){

  	char strg[]="Stringlystring";
  	
  	asm{
  					bra start
  		start:			
  		
  					lea strg, a2 	 // strg in Adressregister a2
  									 // lea load effectiv adress
  		loop:
  					move.b (a2)+,d3	 // a2 byteweise in Datenregister d2
  									 // (a2)+ post incrementiert Addresse byteweise
  					beq loop_end	 // Prüft ob Zeiche = 0 wenn ja dann Sprung 
  									 // auf Marke loop_end
  					move.b	d3,-(sp) // Inhalt von d2 auf Stack
  									 // -(sp) pre decrement reservier von Speicher
  									 // für Char aus d2
  					jsr TERM_Write	 // jsr Jump Subroutine springt in Unterprogramm
  					adda.l #1,sp     // Stack Speicherplatzfreigeben
  					bra loop		 // Branch (Rücksprung) auf loop Marke
  					
  					
  		loop_end:	
  					//jsr TERM_Read    // Warten auf Tastendruck
  		
  	}
	TERM_WriteLn();
	TERM_WriteLn();
}
  
  void strgoutrev(){

  	char strgr[]="Stringlystring";
  	printf("String: %s\r\n",strgr);
  	asm{
  					bra start
  		start:			
  					lea strgr, a2 // strg in Adressregister a2
  					clr.l d3 	  // Register d1 löschen
  		
  		loop_cnt:
  				    add.l #1, d3 // increment counter in d3 um 1
  				    tst.b (a2)+	  // test auf a2 null und  
  				    			  // (a2)+ Byteweise verschieben
  				    bne loop_cnt  // branch not equal
  					
  			        sub.l #1, d3  // Anzahl Zeichen im String ohne 0-Byte
  			        sub.l #1, a2  // Zeiger um 1 zurückgesetzt (jetzt auf 0-Byte)

  			        bra loop_end  // Sprung ans Schleifenende
  			                      // => auch leere Strings werden richtig behandelt
  			                      // => Schleife muss von (AnzahlZeichen - 1) downto 0 laufen
  			        
  		loop_out:	
  					move.b -(a2),-(sp)
  					jsr TERM_Write
  					adda.l #1, sp
  					
  		loop_end:	
  					//subq.l #1, sp alternativ sub quick
  				    sub.l #1,d3
  				    bge loop_out  //branch greater equal loop_cnt
  				    
			
  	}
	TERM_WriteLn();
}
  
  void strgoutrevalt(){
    	

    	char stralt[]="Stringlystring";
    	printf("String: %s\r\n",stralt);
    	asm{
    					bra start
    		start:			
    					lea stralt, a2 		 // stralt in Adressregister a2
    										 // für loop_cnt
    					
    					clr.l d3 	   		 // Register d1 löschen
    		
    		loop_cnt:
    				    add.l #1, d3   		 // increment counter in d3 um 1
    				    tst.b (a2)+	   		 // test auf a2 null und  
    				    			   	     // (a2)+ Byteweise verschieben
    				    bne loop_cnt   		 // branch not equal
    					
    			        //sub.l #1, d3  	     // Anzahl Zeichen im String ohne 0-Byte
    			        lea stralt, a2		 // zurücksetzen der Adresse
    		loop_out:	
    					move.b (a2,d3),-(sp) // Char auf Stack mittles Adressversatz
    										 // d3 counter als byteweiser Adressversatz
    					jsr TERM_Write		 // Jump to Subroutine
    					adda.l #1, sp		 // Speicher auf Stack reservieren
    					subq.l #1, d3		 // Counter erniedrigen
    					tst.b d3			 //	Test ob Counter 0
    					subq.l #1, sp		 // Stackspeicher wieder freigeben
    					
    					beq loop_end		 //	
    					
    					bra loop_out  		 //branch greater equal loop_out
    					
    		loop_end:				  		 //Marke zum beenden der Schleife
	
    	}
  	TERM_WriteLn();
  }

  void IntroUe01(){
		TERM_WriteString("\r\n########################################################################\r\n");
		TERM_WriteString("\r\nUebung01: Ausgabe eines Strings\r\n");
		TERM_WriteString("Mit einer Schleife alle Zeichen des Strings einzeln ausgeben\r\n");
		TERM_WriteString("\r\n########################################################################\r\n\n");
  }
  
  void IntroUe02(){
		TERM_WriteString("\r\n########################################################################\r\n");
		TERM_WriteString("\r\nUebung02: Ausgabe eines Strings (rueckwaerts)\r\n");
		TERM_WriteString("Wie Ue01 aber rueckwaerts (beginnend mit dem letzten Zeichen) ausgeben\r\n");
		TERM_WriteString("\r\n########################################################################\r\n\n");
  }
