/************************************
 * Filename		 : UE01_Strgout.c	*
 * Created on	 : Nov 17, 2018		*
 * Author		 : Christian Zahner	*
 ************************************/


#include "UART0.h"
#include "support_common.h"  // include peripheral declarations and more; 
#include "uart_support.h"    // universal asynchronous receiver transmitter,
                             // (d.h. die serielle Schnittstelle)
#include "terminal_wrapper.h"
#include <stdio.h>

#include "UE01_Strgout.h"


  void strgout(){
  	
  	char strg[]="Stringlystring";
  	
  	asm{
  					bra start
  		start:			
  					//strg: DC.B "StringlyString\n\r" // deklarieren und initialisieren
  													// des String strg
  		
  					lea strg, a2 	 // strg in Adressregister a2
  									 // lea load effectiv adress
  		loop:
  					move.b (a2)+,d3	 // a2 byteweise in Datenregister d2
  									 // (a2)+ post incrementiert Addresse byteweise
  					beq loop_end	 // Prüft ob Zeiche = 0 wenn ja dann Sprung 
  									 // auf Marke loop_end
  					move.b	d3,-(sp) // Inhalt von d2 auf Stack
  									 // -(sp) pre decrement reservier von Speicher
  									 // für Char aus d2
  					jsr TERM_Write	 // jsr Jump Subroutine springt in Unterprogramm
  					adda.l #1,sp     // Stack Speicherplatzfreigeben
  					bra loop		 // Branch (Rücksprung) auf loop Marke
  					
  					
  		loop_end:	
  					//jsr TERM_Read    // Warten auf Tastendruck
  		
  	}
	TERM_WriteLn();
	TERM_WriteLn();
}
  
  void strgoutrev(){
  	
  	char strgr[]=" Stringlystring\r\n";
  	printf("%s",strgr);
  	asm{
  					bra start
  		start:			
  					lea strgr, a2 // strg in Adressregister a2
  					clr.l d3 	  // Register d1 löschen
  		
  		loop_cnt:
  				    add.l #1, d3 // increment counter in d3 um 1
  				    tst.b (a2)+	  // test auf a2 null und  
  				    			  // (a2)+ Byteweise verschieben
  				    bne loop_cnt  // branch not equal
  					
  			        sub.l #1, d3  // Anzahl Zeichen im String ohne 0-Byte
  			        sub.l #1, a2  // Zeiger um 1 zurückgesetzt (jetzt auf 0-Byte)

  			        bra loop_end  // Sprung ans Schleifenende
  			                      // => auch leere Strings werden richtig behandelt
  			                      // => Schleife muss von (AnzahlZeichen - 1) downto 0 laufen
  			        
  		loop_out:	
  					move.b -(a2),-(sp)
  					jsr TERM_Write
  					adda.l #1, sp
  					
  		loop_end:	
  					//subq.l #1, sp alternativ sub quick
  				    sub.l #1,d3
  				    bge loop_out  //branch greater equal loop_cnt
  				    
  				    //jsr TERM_Read
			
  	}
	TERM_WriteLn();
}
  
  void strgoutrevalt(){
    	
    	char stralt[]=" Stringlystring\r\n";
    	printf("%s",stralt);
    	asm{
    					bra start
    		start:			
    					lea stralt, a2 		 // stralt in Adressregister a2
    										 // für loop_cnt
    					lea stralt, a3		 // für loop_out
    					clr.l d3 	   		 // Register d1 löschen
    		
    		loop_cnt:
    				    add.l #1, d3   		 // increment counter in d3 um 1
    				    tst.b (a2)+	   		 // test auf a2 null und  
    				    			   	     // (a2)+ Byteweise verschieben
    				    bne loop_cnt   		 // branch not equal
    					
    			        sub.l #1, d3  	     // Anzahl Zeichen im String ohne 0-Byte
    			        
    		loop_out:	
    					move.b (a3,d3),-(sp) //
    					jsr TERM_Write
    					adda.l #1, sp
    					subq.l #1,d3
    					tst.b d3
    					subq.l #1, sp // Stackspeicher wieder freigeben
    					
    					beq loop_end
    					
    					bra loop_out  //branch greater equal loop_out
    					
    		loop_end:				  //MArke zum beenden der Schleife
	
    	}
  	TERM_WriteLn();
  }
