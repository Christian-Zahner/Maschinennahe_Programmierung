/***********************************
 * Filename		 : UE09_LED.h      *
 * Created on	 : Dec 11, 2018    *
 * Author		 : Christian Zahner*
 ***********************************/

/* ###################################################################
**     Filename    : main.c
**     Project     : test9a
**     Processor   : MCF52259CAG80
**     Version     : Driver 01.00
**     Compiler    : CodeWarrior MCF C Compiler
**     Date/Time   : 2014-10-11, 15:20, # CodeGen: 0 
**     Abstract    :
**         Main module.
**         This module contains user's application code.
**     Settings    :
**     Contents    :
**         No public methods
**
** ###################################################################*/
/*!
** @file main.c
** @version 01.00
** @brief
**         Main module.
**         This module contains user's application code.
*/                  
/* MODULE main */ 
 
#pragma compact_abi 
 

#include "UART0.h"
#include "support_common.h"  // include peripheral declarations and more; 
#include "uart_support.h"    // universal asynchronous receiver transmitter,
                             // (d.h. die serielle Schnittstelle)
#include "terminal_wrapper.h"

#include "UE09_LED.h"


// - Bitte darauf achten, dass am Coldfire-Serial Port ein  
//   Terminal (Putty o.ä.) mit 19200kBaud angeschlossen ist.
// - Als Target muss   <projektname>_RAM_OSBDM   ausgewählt werden.



  #define IPS 0x40000000

  /* Definitions for MCF_GPIO Port NQ */
  #define PORTNQ 			     0x40100008	//Output
  #define PNQPAR 			  	 0x40100068 // GPIO einstellen
  #define DDRNQ					 0x40100020
  #define PINDATANQ			     0x40100038	// Auslesen PIN
  #define CLRNQ				     0x40100068

  #define ORTNQ1 			     0x00000002
  #define PORTNQ5   			 0x00000020


  /* Bit definitions for MCF_GPIO Port TC */
  #define PORTTC        		 0x4010000F //Output
  #define PTCPAR  				 0x4010006F
  #define DDRTC					 0x40100027	// Datenrichtung
  #define SETDATATC				 0x4010003F // Set
  #define CLRTC			 		 0x40100057

  #define PORTTC0				 0x00000001
  #define PORTTC1   			 0x00000002
  #define PORTTC2   			 0x00000004
  #define PORTTC3  				 0x00000008


  void ledOnOff()
  {

  asm 
  {
  	/* MCF52259RM.pdf
  	- SW1 and SW2 are connected to PNQPAR5 and PNQPAR1 (Quad function pins!!)
  	- LED's 1-4 are connected to DDRTC0-DDRTC3
  	*/
  	
     /* Enable Switches to be pollable ====================================== */
     /* MCF52259RM.pdf
     - Pin Assignment must be set to GPIO function 
       (15.6.5.3 Port NQ Pin Assignment Register (PNQPAR))
     - Port Data Direction must be cleared for input function 
       (15.6.2 Port Data Direction Registers (DDRn))
     - Output Data Register must be cleared 
       (15.6.1 Port Output Data Registers (PORTn))
     */

     
     move.w		PNQPAR,  d0
     and.l      #0xF0F0, d0
     move.w		d0,  PNQPAR
     
     move.b		DDRNQ,  d0
     and.l		#0xDD,  d0
     move.b		d0,  DDRNQ

     
     move.b		CLRNQ,  d0
     and.l		#0xDD,  d0
     move.b		d0,  DDRNQ
     
     /* Enable LEDs as digital outputs ==================================== */
  	/* MCF52259RM.pdf
  	- Port Data Direction must be set for output function 
  	  (15.6.2 Port Data Direction Registers (DDRn))
  	- Pin Assignment must be set to GPIO function 
  	  (15.6.5.1 Dual-Function Pin Assignment Registers)
     - Output Data Register must be set/reset 
       (15.6.1 Port Output Data Registers (PORTn))
  	*/
     
     clr.b		PTCPAR
        
     move.b		#0xF,  d0
     move.b		d0, DDRTC
     
     clr.b 		CLRTC
     
     loop:

     ////////////////////////// Taster 1 schaltet LED 1
     
     	clr.l    d0                 // Reset D0
  	    move.b   PINDATANQ, d0 		// Taster via PINDATA_SETNQ abfragen
     	andi.l   #PORTNQ5, d0   	// Check NQ5 auf 0 (SW1 gedrückt)
     	bne      LED1_OFF                   // falls nicht gedrückt: Sprung
  	
       	move.l   #PORTTC,d1
     	move.b	 d1, SETTC         	// LED einschalten via set bit in GPIO_SET
     	bra      LED1_END
  	
     LED1_OFF:	
     	move.l   #~(ORTTC0),d1
     	move.b   d1, CLRTC         	// LED ausschalten via clear bit in GPIO_CLR

     LED1_END:	

     // Nochmal dasselbe für Nr. 2:
     ////////////////////////// Taster 2 schaltet LED 2
     
     	clr.l    d0
     	move.b   PINDATANQ, d0   	// Taster via PINDATA_SETNQ abfragen
     	andi.l   #PORTNQ1,  d0  	// Check NQ1 auf 0 (SW2 gedrückt)
     	bne      LED2_OFF
  	
     	move.l   #PORTTC1,  d1
     	move.b   d1, SETTC         // LED einschalten via set bit in GPIO_SET
     	bra      LED2_END
  	
     LED2_OFF:	
     	move.l   #~(PORTTC1),d1
     	move.b   d1, CLRTC         // LED ausschalten via clear bit in GPIO_CLR

  	
     LED2_END:	
     	bra	    loop

     }

  }
  
  void ledLatched(){
	  
  }
  void ledCount(){
	  
  }
  void ledInterrupt(){
	  
  }

  void IntroUe09(){
   	TERM_WriteString("\n########################################################################\r\n");
   	TERM_WriteString("\nUebung09: Ansteuerung der Leuchtdioden bei Tastendruck\r\n\n");
   	TERM_WriteString("          Programmieren Sie den Mikrocontroller so, dass bei   \r\n");
   	TERM_WriteString("          Betaetigung der Tasten SW1 und/oder SW2 eine Anzeige an den \r\n");
   	TERM_WriteString("          Leuchtdioden erfolgt\r\n");
   	
  }
  
  void IntroUe09A(){
    TERM_WriteString("\n09a) LED leuchtet, solange der entsprechende Schalter betaetigt ist.\r\n");
    TERM_WriteString("\n########################################################################\r\n");
  }
  
  void IntroUe09B(){
    TERM_WriteString("\n09b) LED wechselt (ein -aus - ein usw.-) mit jeder Schalterbetaetigung.\r\n");
    TERM_WriteString("\n########################################################################\r\n");
  }
  
  void IntroUe09C(){
    TERM_WriteString("\n09c) Die vier LEDs zaehlen binaer mit jeder Schalterbetaetigung von SW1.\r\n");
    TERM_WriteString("\n########################################################################\r\n");
  }
  
  void IntroUe09D(){
    TERM_WriteString("\n09d) SW1 schaltet eine LED ein, SW2 schaltet sie wieder aus.\r\n");
    TERM_WriteString("     WOBEI AUF SW1 UND SW2 PER INTERRUPT REAGIERT WERDEN SOLL.\r\n");
    TERM_WriteString("\n########################################################################\r\n");
  }
